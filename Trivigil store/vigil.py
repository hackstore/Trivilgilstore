import os
import logging
import sqlite3
import threading
import time
import asyncio
import html
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, request, render_template_string
from telegram import Update, Bot
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters
)
import google.generativeai as genai
import dotenv
from telegram.error import InvalidToken  # Added import for token validation

# Load environment variables - Load multiple times for reliability
dotenv.load_dotenv()
if not all([os.getenv('TELEGRAM_TOKEN'), os.getenv('GEMINI_API_KEY')]):
    dotenv.load_dotenv(dotenv_path='.env', override=True)

# Configuration - Use environment variables for production
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
ADMIN_TOKEN = os.getenv('ADMIN_TOKEN', 'secure_admin_token')
DB_NAME = 'chatbot.db'
LOG_FILE = 'chatbot.log'
REQUEST_LIMIT = 3  # Max requests per user
REQUEST_WINDOW = 30  # Seconds
FOOTER = '''\n\n
‚ï≠‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ ‚ú© ‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ‚ïÆ
  Generated by @VigilAIRobot
‚ï∞‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ ‚ú© ‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ‚ïØ'''  # Added footer
MAX_MESSAGE_LENGTH = 4096  # Telegram message limit

# Block reason constants (from genai.types.BlockReason)
BLOCK_REASON_UNSPECIFIED = 0
BLOCK_REASON_SAFETY = 1
BLOCK_REASON_OTHER = 2

# Finish reason constants (from genai.types.FinishReason)
FINISH_REASON_SAFETY = 3

# Configure logging to both file and terminal
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Create file handler
file_handler = logging.FileHandler(LOG_FILE)
file_handler.setLevel(logging.INFO)

# Create console handler
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)

# Create formatter and add it to handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# Validate critical environment variables
if not TELEGRAM_TOKEN or not GEMINI_API_KEY:
    logger.error("CRITICAL: Missing required environment variables!")
    logger.error(f"TELEGRAM_TOKEN: {'Set' if TELEGRAM_TOKEN else 'Missing'}")
    logger.error(f"GEMINI_API_KEY: {'Set' if GEMINI_API_KEY else 'Missing'}")
    logger.error("Please create a .env file with these variables or set them in your environment")
    exit(1)

# Initialize Gemini
genai.configure(api_key=GEMINI_API_KEY)

# Try different models in order of preference
model = None
model_names = ['gemini-2.0-flash', 'gemini-1.0-pro', 'gemini-pro']
for model_name in model_names:
    try:
        model = genai.GenerativeModel(model_name)
        # Test the model connection
        model.generate_content("Test connection")
        logger.info(f"Using model: {model_name}")
        break
    except Exception as e:
        logger.warning(f"Model {model_name} failed: {e}")
        continue

if model is None:
    logger.error("All models failed to initialize. Exiting.")
    exit(1)

safety_settings = [
    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
]

# Database setup
def init_db():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER UNIQUE,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            response TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS groups (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            group_id INTEGER UNIQUE,
            title TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

init_db()

# User management
def register_user(user_data):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute('''
            INSERT OR IGNORE INTO users (user_id, username, first_name, last_name)
            VALUES (?, ?, ?, ?)
        ''', (
            user_data.id,
            user_data.username,
            user_data.first_name,
            user_data.last_name
        ))
        conn.commit()
    except sqlite3.Error as e:
        logger.error(f"Database error: {e}")
    finally:
        conn.close()

# Group management
def register_group(group_id, title):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute('''
            INSERT OR IGNORE INTO groups (group_id, title)
            VALUES (?, ?)
        ''', (group_id, title))
        conn.commit()
    except sqlite3.Error as e:
        logger.error(f"Database error: {e}")
    finally:
        conn.close()

def save_message(user_id, message, response):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute('''
            INSERT INTO messages (user_id, message, response)
            VALUES (?, ?, ?)
        ''', (user_id, message, response))
        conn.commit()
    except sqlite3.Error as e:
        logger.error(f"Database error: {e}")
    finally:
        conn.close()

# Rate limiting
user_requests = {}
def is_rate_limited(user_id):
    current_time = time.time()
    if user_id not in user_requests:
        user_requests[user_id] = [current_time]
        return False
    
    # Remove old requests
    user_requests[user_id] = [t for t in user_requests[user_id] 
                             if current_time - t < REQUEST_WINDOW]
    
    if len(user_requests[user_id]) >= REQUEST_LIMIT:
        return True
    
    user_requests[user_id].append(current_time)
    return False

# Telegram Handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    register_user(user)
    await update.message.reply_text(
        "üëã Hello! I'm your Gemini-powered assistant. Use /askai followed by your question to chat with me.\n\n"
        "Other commands:\n"
        "/help - Show help\n"
        "/reset - Reset conversation context\n"
        "/clearhistory - Delete your chat history"
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "ü§ñ How to use this bot:\n\n"
        "/askai <your question> - Get AI response\n"
        "/reset - Reset conversation context\n"
        "/clearhistory - Delete your stored messages\n\n"
        "You can also mention me in groups: @VigilAIRobot <question>"
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message
    user = message.from_user
    register_user(user)

    # Register group if in a group
    if message.chat.type in ['group', 'supergroup']:
        register_group(message.chat.id, message.chat.title)

    # Handle group mentions
    if message.chat.type in ['group', 'supergroup']:
        if not (message.text and (f'@{context.bot.username}' in message.text)):
            return
        
        # Check if bot is admin in the group
        try:
            chat_member = await context.bot.get_chat_member(
                chat_id=message.chat.id, 
                user_id=context.bot.id
            )
            if chat_member.status not in ['administrator', 'creator']:
                if message.text.startswith('/'):
                    # Don't respond to commands if not admin
                    return
                await message.reply_text(
                    "‚ö†Ô∏è I need to be an admin in this group to respond to messages. "
                    "Please make me an admin to use my features."
                )
                return
        except Exception as e:
            logger.error(f"Admin check error: {e}")
            return
        
        question = message.text.split(f'@{context.bot.username}', 1)[1].strip()
    else:
        question = message.text.strip()

    await ai_response(update, context, question)

async def ask_ai(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    question = ' '.join(context.args).strip()
    
    if not question:
        await update.message.reply_text("Please provide a question after /askai command.")
        return
    
    # Check if in group and is admin
    if update.message.chat.type in ['group', 'supergroup']:
        try:
            chat_member = await context.bot.get_chat_member(
                chat_id=update.message.chat.id, 
                user_id=context.bot.id
            )
            if chat_member.status not in ['administrator', 'creator']:
                await update.message.reply_text(
                    "‚ö†Ô∏è I need to be an admin in this group to respond to commands. "
                    "Please make me an admin to use my features."
                )
                return
        except Exception as e:
            logger.error(f"Admin check error: {e}")
            return
    
    await ai_response(update, context, question)

def split_message(text, max_length=MAX_MESSAGE_LENGTH):
    """Split long messages into chunks that fit Telegram's limits"""
    if len(text) <= max_length:
        return [text]
    
    chunks = []
    while text:
        # Try to split at a paragraph boundary
        split_index = text.rfind('\n\n', 0, max_length)
        if split_index == -1:
            # If no paragraph break, split at last space
            split_index = text.rfind(' ', 0, max_length)
        if split_index == -1:
            # If no space, force split
            split_index = max_length
        
        chunk = text[:split_index].strip()
        if chunk:
            chunks.append(chunk)
        text = text[split_index:].strip()
    
    return chunks

async def send_message_with_retry(update, text, parse_mode=None):
    """Send a message with formatting fallbacks"""
    try:
        # Try with specified parse mode
        await update.message.reply_text(
            text,
            parse_mode=parse_mode,
            disable_web_page_preview=True
        )
        return True
    except Exception as e:
        logger.error(f"Error sending with {parse_mode}: {e}")
        return False

async def send_message_chunks(update, chunks):
    """Send message chunks with proper formatting"""
    for i, chunk in enumerate(chunks):
        # Send with HTML formatting first
        if not await send_message_with_retry(update, chunk, ParseMode.HTML):
            # If HTML fails, try Markdown
            if not await send_message_with_retry(update, chunk, ParseMode.MARKDOWN_V2):
                # If Markdown fails, send as plain text
                await update.message.reply_text(chunk)

async def ai_response(update: Update, context: ContextTypes.DEFAULT_TYPE, question: str):
    user = update.effective_user
    
    # Check if model is initialized
    if model is None:
        logger.error("Gemini model not initialized")
        await update.message.reply_text("‚ö†Ô∏è Bot configuration error. Please contact the administrator.")
        return
    
    # Rate limiting
    if is_rate_limited(user.id):
        await update.message.reply_text(
            "‚è≥ You're sending requests too fast. Please wait 30 seconds between requests."
        )
        return
    
    try:
        # Show typing indicator
        await context.bot.send_chat_action(
            chat_id=update.effective_chat.id, 
            action='typing'
        )
        
        # Generate response
        response = model.generate_content(
            question,
            safety_settings=safety_settings,
            generation_config=genai.types.GenerationConfig(
                temperature=0.7,
                max_output_tokens=1024
            )
        )
        
        # Handle blocked responses
        if response.prompt_feedback and response.prompt_feedback.block_reason != BLOCK_REASON_UNSPECIFIED:
            reasons = {
                BLOCK_REASON_SAFETY: "content safety policies",
                BLOCK_REASON_OTHER: "unknown policies"
            }
            reason = reasons.get(response.prompt_feedback.block_reason, "safety policies")
            reply = f"‚ö†Ô∏è Your request was blocked due to {reason}."
            logger.warning(f"Blocked prompt from user {user.id}: {question}")
        
        # Handle blocked output
        elif response.candidates and response.candidates[0].finish_reason == FINISH_REASON_SAFETY:
            reply = "‚ö†Ô∏è The response was blocked due to safety concerns."
            logger.warning(f"Blocked output for user {user.id}: {question}")
        
        # Handle successful response
        elif response.text:
            # Add footer to successful responses
            reply = response.text + FOOTER
            logger.info(f"Response generated for user {user.id}")
        
        # Fallback for empty responses
        else:
            reply = "‚ö†Ô∏è I couldn't generate a response for that query."
            logger.error(f"Empty response for user {user.id}: {question}")
        
        # Split long messages into chunks
        chunks = split_message(reply)
        
        # Send message chunks
        await send_message_chunks(update, chunks)
        
        # Save to DB
        save_message(user.id, question, reply)
        
    except Exception as e:
        logger.error(f"Gemini error: {e}", exc_info=True)
        await update.message.reply_text("‚ö†Ô∏è Sorry, I encountered an error processing your request.")

async def reset_context(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # In future implementations, this would reset conversation history
    await update.message.reply_text("üîÑ Conversation context has been reset!")

async def clear_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute('DELETE FROM messages WHERE user_id = ?', (user.id,))
        conn.commit()
        await update.message.reply_text("üßπ Your chat history has been cleared!")
    except sqlite3.Error as e:
        logger.error(f"Clear history error: {e}")
        await update.message.reply_text("‚ö†Ô∏è Failed to clear your history.")
    finally:
        conn.close()

# Set bot commands description for Telegram UI
async def post_init(application: Application):
    try:
        await application.bot.set_my_commands([
            ("start", "Start the bot"),
            ("help", "Show help information"),
            ("askai", "Ask the AI a question"),
            ("reset", "Reset conversation context"),
            ("clearhistory", "Clear your chat history")
        ])
        logger.info("Bot commands set successfully")
    except Exception as e:
        logger.error(f"Error setting bot commands: {e}")

# Flask Admin Interface
app = Flask(__name__)

HTML_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>Telegram Bot Admin</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .section { margin-bottom: 30px; }
        .stats { background: #f5f5f5; padding: 15px; border-radius: 5px; }
        form { background: #f9f9f9; padding: 20px; border-radius: 5px; }
        input, textarea, button { width: 100%; padding: 10px; margin: 5px 0; }
        .messages { margin-top: 20px; }
        .message { border-bottom: 1px solid #eee; padding: 10px; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Telegram Bot Admin Panel</h1>
        
        <div class="section">
            <div class="stats">
                <h2>Bot Status: <span style="color:green;">Running</span></h2>
                <p>Users Registered: {{ user_count }}</p>
                <p>Groups Registered: {{ group_count }}</p>
                <p>Messages Processed: {{ message_count }}</p>
            </div>
        </div>

        <div class="section">
            <h2>Broadcast Message</h2>
            <form method="POST" action="/broadcast">
                <input type="password" name="token" placeholder="Admin Token" required>
                <textarea name="message" rows="4" placeholder="Your message to all users" required></textarea>
                <button type="submit">Send Broadcast</button>
            </form>
            {% if broadcast_result %}
                <div class="broadcast-result">
                    <p class="success">{{ broadcast_result }}</p>
                </div>
            {% endif %}
            {% if broadcast_error %}
                <div class="error">
                    <p>{{ broadcast_error }}</p>
                </div>
            {% endif %}
        </div>

        <div class="section">
            <h2>Recent Messages (Last 10)</h2>
            <div class="messages">
                {% for msg in recent_messages %}
                <div class="message">
                    <strong>{{ msg.username }} ({{ msg.user_id }})</strong>
                    <p>{{ msg.message }}</p>
                    <small>{{ msg.timestamp }}</small>
                </div>
                {% endfor %}
            </div>
        </div>
    </div>
</body>
</html>
"""

@app.route('/')
def home():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    cursor.execute('SELECT COUNT(*) FROM users')
    user_count = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM groups')
    group_count = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM messages')
    message_count = cursor.fetchone()[0]
    
    cursor.execute('''
        SELECT m.message, m.timestamp, u.user_id, u.username 
        FROM messages m
        JOIN users u ON m.user_id = u.user_id
        ORDER BY m.timestamp DESC
        LIMIT 10
    ''')
    recent_messages = cursor.fetchall()
    conn.close()
    
    messages_formatted = [
        {
            'message': msg[0],
            'timestamp': msg[1],
            'user_id': msg[2],
            'username': msg[3] or f"User {msg[2]}"
        } for msg in recent_messages
    ]
    
    return render_template_string(HTML_TEMPLATE, 
        user_count=user_count,
        group_count=group_count,
        message_count=message_count,
        recent_messages=messages_formatted
    )

async def async_broadcast(bot, user_ids, message_text):
    success = 0
    failures = 0
    for user_id in user_ids:
        try:
            await bot.send_message(
                chat_id=user_id, 
                text=message_text,
                parse_mode=ParseMode.HTML
            )
            success += 1
            # Avoid hitting rate limits
            await asyncio.sleep(0.1)
        except Exception as e:
            logger.error(f"Broadcast failed for {user_id}: {e}")
            failures += 1
    return success, failures

@app.route('/broadcast', methods=['POST'])
def broadcast():
    token = request.form.get('token')
    message = request.form.get('message').strip()
    
    if token != ADMIN_TOKEN:
        return render_template_string(HTML_TEMPLATE, 
            user_count=0,
            group_count=0,
            message_count=0,
            recent_messages=[],
            broadcast_error="Invalid admin token"
        )
    
    if not message:
        return render_template_string(HTML_TEMPLATE, 
            user_count=0,
            group_count=0,
            message_count=0,
            recent_messages=[],
            broadcast_error="Message cannot be empty"
        )
    
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute('SELECT user_id FROM users')
    user_ids = [row[0] for row in cursor.fetchall()]
    conn.close()
    
    message_text = f"üì¢ <b>Broadcast Message</b> üì¢\n\n{message}"
    
    # Run broadcast in a separate thread to avoid blocking
    def run_broadcast():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        bot = Bot(token=TELEGRAM_TOKEN)
        result = loop.run_until_complete(async_broadcast(bot, user_ids, message_text))
        loop.close()
        return result
    
    try:
        # Execute broadcast in a thread to avoid blocking Flask
        with ThreadPoolExecutor() as executor:
            future = executor.submit(run_broadcast)
            success, failures = future.result(timeout=300)  # 5 minute timeout
        
        result = f"Broadcast sent to {success} users. Failed: {failures}"
        
        # Get updated stats
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute('SELECT COUNT(*) FROM users')
        user_count = cursor.fetchone()[0]
        cursor.execute('SELECT COUNT(*) FROM groups')
        group_count = cursor.fetchone()[0]
        cursor.execute('SELECT COUNT(*) FROM messages')
        message_count = cursor.fetchone()[0]
        cursor.execute('''
            SELECT m.message, m.timestamp, u.user_id, u.username 
            FROM messages m
            JOIN users u ON m.user_id = u.user_id
            ORDER BY m.timestamp DESC
            LIMIT 10
        ''')
        recent_messages = cursor.fetchall()
        conn.close()
        
        messages_formatted = [
            {
                'message': msg[0],
                'timestamp': msg[1],
                'user_id': msg[2],
                'username': msg[3] or f"User {msg[2]}"
            } for msg in recent_messages
        ]
        
        return render_template_string(HTML_TEMPLATE, 
            user_count=user_count,
            group_count=group_count,
            message_count=message_count,
            recent_messages=messages_formatted,
            broadcast_result=result
        )
    except Exception as e:
        logger.error(f"Broadcast execution error: {e}")
        return render_template_string(HTML_TEMPLATE, 
            user_count=0,
            group_count=0,
            message_count=0,
            recent_messages=[],
            broadcast_error=f"Broadcast failed: {str(e)}"
        )

# Main Application
def run_flask():
    app.run(host='0.0.0.0', port=5000, use_reloader=False)

def main():
    # Validate token format before proceeding
    try:
        # Test token validity
        test_bot = Bot(token=TELEGRAM_TOKEN)
        asyncio.get_event_loop().run_until_complete(test_bot.get_me())
        logger.info("Telegram token validated successfully")
    except InvalidToken as e:
        logger.error("Invalid Telegram token! Please check your .env file")
        logger.error("Error details: %s", e)
        logger.error("Token format should be: [numbers]:[alphanumeric string]")
        logger.error("Example: 1234567890:ABCdefGHIJKLMnopqrstUVWXYZ123456")
        return
    except Exception as e:
        logger.error("Error validating Telegram token: %s", e)
        return

    # Start Flask in a separate thread
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True
    flask_thread.start()

    # Create Telegram Application with post_init
    application = Application.builder() \
        .token(TELEGRAM_TOKEN) \
        .post_init(post_init) \
        .build()

    # Add handlers with lowercase commands
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("askai", ask_ai))
    application.add_handler(CommandHandler("reset", reset_context))
    application.add_handler(CommandHandler("clearhistory", clear_history))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Start polling
    logger.info("Bot is running...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
