import os
import logging
import sqlite3
import threading
import time
import asyncio
import html
import re
import json
import hashlib
import secrets
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from contextlib import asynccontextmanager
from pathlib import Path

from flask import Flask, request, render_template_string, jsonify, session, redirect
from telegram import Update, Bot, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode, ChatAction
from telegram.helpers import escape_markdown
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
    CallbackQueryHandler
)
import google.generativeai as genai
import dotenv
from telegram.error import InvalidToken, BadRequest, Forbidden, TimedOut
from werkzeug.security import generate_password_hash, check_password_hash

# Load environment variables
dotenv.load_dotenv()
if not all([os.getenv('TELEGRAM_TOKEN'), os.getenv('GEMINI_API_KEY')]):
    dotenv.load_dotenv(dotenv_path='.env', override=True)

# Enhanced Configuration
@dataclass
class BotConfig:
    telegram_token: str
    gemini_api_key: str
    admin_token: str
    db_name: str = 'chatbot.db'
    log_file: str = 'chatbot.log'
    request_limit: int = 5
    request_window: int = 60
    max_message_length: int = 4096
    max_history_messages: int = 15
    max_history_tokens: int = 3000
    flask_port: int = 5000
    flask_host: str = '0.0.0.0'
    backup_interval: int = 3600  # 1 hour
    log_retention_days: int = 7

# Initialize configuration
config = BotConfig(
    telegram_token=os.getenv('TELEGRAM_TOKEN'),
    gemini_api_key=os.getenv('GEMINI_API_KEY'),
    admin_token=os.getenv('ADMIN_TOKEN', secrets.token_urlsafe(32))
)

# Constants
FOOTER = '''\n\n
‚ï≠‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ ‚ú© ‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ‚ïÆ
  Generated by @VigilAIRobot
‚ï∞‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ ‚ú© ‚îÄ‚îÄ‚îÄ ‚ãÖ ‚ãÖ ‚îÄ‚îÄ‚îÄ‚ïØ'''

# Block and finish reason constants
BLOCK_REASON_UNSPECIFIED = 0
BLOCK_REASON_SAFETY = 1
BLOCK_REASON_OTHER = 2
FINISH_REASON_SAFETY = 3

# Enhanced logging setup
def setup_logging():
    """Set up comprehensive logging with rotation"""
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # Create logs directory if it doesn't exist
    Path('logs').mkdir(exist_ok=True)
    
    # File handler with rotation
    from logging.handlers import RotatingFileHandler
    file_handler = RotatingFileHandler(
        f'logs/{config.log_file}',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(logging.INFO)
    
    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    # Enhanced formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
    )
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

logger = setup_logging()

# Validate environment variables
def validate_config():
    """Validate all required configuration"""
    if not config.telegram_token or not config.gemini_api_key:
        logger.error("CRITICAL: Missing required environment variables!")
        logger.error(f"TELEGRAM_TOKEN: {'Set' if config.telegram_token else 'Missing'}")
        logger.error(f"GEMINI_API_KEY: {'Set' if config.gemini_api_key else 'Missing'}")
        return False
    return True

if not validate_config():
    exit(1)

# Enhanced Gemini initialization
class GeminiManager:
    def __init__(self):
        self.model = None
        self.model_name = None
        self.safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
        ]
        self.initialize_model()
    
    def initialize_model(self):
        """Initialize Gemini model with fallback options"""
        genai.configure(api_key=config.gemini_api_key)
        
        model_names = [
            'gemini-2.0-flash-exp',
            'gemini-2.0-flash',
            'gemini-1.5-pro',
            'gemini-1.5-flash',
            'gemini-1.0-pro'
        ]
        
        for model_name in model_names:
            try:
                model = genai.GenerativeModel(model_name)
                # Test the model
                test_response = model.generate_content(
                    "Hello",
                    safety_settings=self.safety_settings
                )
                if test_response.text:
                    self.model = model
                    self.model_name = model_name
                    logger.info(f"Successfully initialized model: {model_name}")
                    return
            except Exception as e:
                logger.warning(f"Model {model_name} failed: {e}")
                continue
        
        logger.error("All Gemini models failed to initialize")
        raise Exception("Could not initialize any Gemini model")
    
    def generate_response(self, prompt: str, history: List = None) -> str:
        """Generate response with enhanced error handling"""
        try:
            if history:
                chat = self.model.start_chat(history=history)
                response = chat.send_message(
                    prompt,
                    safety_settings=self.safety_settings,
                    generation_config=genai.types.GenerationConfig(
                        temperature=0.7,
                        max_output_tokens=1024,
                        top_p=0.8,
                        top_k=40
                    )
                )
            else:
                response = self.model.generate_content(
                    prompt,
                    safety_settings=self.safety_settings,
                    generation_config=genai.types.GenerationConfig(
                        temperature=0.7,
                        max_output_tokens=1024,
                        top_p=0.8,
                        top_k=40
                    )
                )
            
            return self._handle_response(response)
        except Exception as e:
            logger.error(f"Gemini generation error: {e}")
            raise

    def _handle_response(self, response) -> str:
        """Handle Gemini response with all edge cases"""
        # Handle blocked prompts
        if response.prompt_feedback and response.prompt_feedback.block_reason != BLOCK_REASON_UNSPECIFIED:
            reasons = {
                BLOCK_REASON_SAFETY: "content safety policies",
                BLOCK_REASON_OTHER: "unknown policies"
            }
            reason = reasons.get(response.prompt_feedback.block_reason, "safety policies")
            return f"‚ö†Ô∏è Your request was blocked due to {reason}."
        
        # Handle blocked outputs
        if response.candidates and response.candidates[0].finish_reason == FINISH_REASON_SAFETY:
            return "‚ö†Ô∏è The response was blocked due to safety concerns."
        
        # Handle successful response
        if response.text:
            return response.text
        
        # Fallback for empty responses
        return "‚ö†Ô∏è I couldn't generate a response for that query."

# Initialize Gemini manager
try:
    gemini_manager = GeminiManager()
except Exception as e:
    logger.error(f"Failed to initialize Gemini: {e}")
    exit(1)

# Enhanced Database Management
class DatabaseManager:
    def __init__(self, db_name: str):
        self.db_name = db_name
        self.init_db()
    
    def get_connection(self):
        """Get database connection with proper configuration"""
        conn = sqlite3.connect(
            self.db_name,
            timeout=30,
            check_same_thread=False
        )
        conn.row_factory = sqlite3.Row
        return conn
    
    def init_db(self):
        """Initialize database with enhanced schema"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        # Users table with enhanced fields
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER UNIQUE NOT NULL,
                username TEXT,
                first_name TEXT,
                last_name TEXT,
                language_code TEXT,
                is_premium INTEGER DEFAULT 0,
                is_blocked INTEGER DEFAULT 0,
                last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Messages table with enhanced tracking
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                chat_id INTEGER NOT NULL,
                message_text TEXT NOT NULL,
                response_text TEXT,
                tokens_used INTEGER DEFAULT 0,
                processing_time REAL DEFAULT 0,
                model_used TEXT,
                status TEXT DEFAULT 'success',
                error_message TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(user_id) REFERENCES users(user_id)
            )
        ''')
        
        # Groups table with enhanced info
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS groups (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                group_id INTEGER UNIQUE NOT NULL,
                title TEXT,
                type TEXT,
                is_active INTEGER DEFAULT 1,
                member_count INTEGER DEFAULT 0,
                last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Analytics table for tracking
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS analytics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date DATE NOT NULL,
                total_messages INTEGER DEFAULT 0,
                unique_users INTEGER DEFAULT 0,
                errors INTEGER DEFAULT 0,
                blocked_requests INTEGER DEFAULT 0,
                avg_response_time REAL DEFAULT 0,
                UNIQUE(date)
            )
        ''')
        
        # Admin users table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS admin_users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER UNIQUE NOT NULL,
                username TEXT,
                permissions TEXT DEFAULT 'basic',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create indexes for better performance
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_messages_user_id ON messages(user_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_messages_chat_id ON messages(chat_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_users_user_id ON users(user_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_analytics_date ON analytics(date)')
        
        conn.commit()
        conn.close()
        logger.info("Database initialized successfully")
    
    def register_user(self, user_data) -> bool:
        """Register or update user with enhanced data"""
        conn = self.get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute('''
                INSERT OR REPLACE INTO users 
                (user_id, username, first_name, last_name, language_code, is_premium, last_active, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
            ''', (
                user_data.id,
                user_data.username,
                user_data.first_name,
                user_data.last_name,
                getattr(user_data, 'language_code', 'en'),
                getattr(user_data, 'is_premium', False)
            ))
            conn.commit()
            return True
        except sqlite3.Error as e:
            logger.error(f"Database error in register_user: {e}")
            return False
        finally:
            conn.close()
    
    def register_group(self, group_id: int, title: str, group_type: str = 'group') -> bool:
        """Register or update group information"""
        conn = self.get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute('''
                INSERT OR REPLACE INTO groups 
                (group_id, title, type, last_activity)
                VALUES (?, ?, ?, CURRENT_TIMESTAMP)
            ''', (group_id, title, group_type))
            conn.commit()
            return True
        except sqlite3.Error as e:
            logger.error(f"Database error in register_group: {e}")
            return False
        finally:
            conn.close()
    
    def save_message(self, user_id: int, chat_id: int, message: str, response: str, 
                    tokens_used: int = 0, processing_time: float = 0, 
                    model_used: str = None, status: str = 'success', 
                    error_message: str = None) -> bool:
        """Save message with enhanced tracking"""
        conn = self.get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute('''
                INSERT INTO messages 
                (user_id, chat_id, message_text, response_text, tokens_used, 
                 processing_time, model_used, status, error_message)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (user_id, chat_id, message, response, tokens_used, 
                  processing_time, model_used or gemini_manager.model_name, 
                  status, error_message))
            conn.commit()
            return True
        except sqlite3.Error as e:
            logger.error(f"Database error in save_message: {e}")
            return False
        finally:
            conn.close()
    
    def get_chat_history(self, chat_id: int, limit: int = None) -> List[Dict]:
        """Get chat history with enhanced formatting"""
        conn = self.get_connection()
        cursor = conn.cursor()
        try:
            limit = limit or config.max_history_messages
            cursor.execute('''
                SELECT message_text, response_text, timestamp 
                FROM messages 
                WHERE chat_id = ? AND status = 'success'
                ORDER BY timestamp DESC 
                LIMIT ?
            ''', (chat_id, limit))
            
            rows = cursor.fetchall()
            history = []
            for row in reversed(rows):
                history.append({'role': 'user', 'parts': [row['message_text']]})
                history.append({'role': 'model', 'parts': [row['response_text']]})
            
            return history
        except sqlite3.Error as e:
            logger.error(f"Database error in get_chat_history: {e}")
            return []
        finally:
            conn.close()
    
    def get_user_stats(self, user_id: int) -> Dict:
        """Get user statistics"""
        conn = self.get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute('''
                SELECT COUNT(*) as total_messages,
                       AVG(processing_time) as avg_processing_time,
                       MAX(timestamp) as last_message
                FROM messages 
                WHERE user_id = ?
            ''', (user_id,))
            
            result = cursor.fetchone()
            return {
                'total_messages': result['total_messages'],
                'avg_processing_time': result['avg_processing_time'] or 0,
                'last_message': result['last_message']
            }
        except sqlite3.Error as e:
            logger.error(f"Database error in get_user_stats: {e}")
            return {'total_messages': 0, 'avg_processing_time': 0, 'last_message': None}
        finally:
            conn.close()
    
    def clear_user_history(self, user_id: int, chat_id: int) -> bool:
        """Clear user's chat history"""
        conn = self.get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute('DELETE FROM messages WHERE user_id = ? AND chat_id = ?', 
                          (user_id, chat_id))
            conn.commit()
            return True
        except sqlite3.Error as e:
            logger.error(f"Database error in clear_user_history: {e}")
            return False
        finally:
            conn.close()
    
    def get_analytics(self, days: int = 7) -> Dict:
        """Get bot analytics"""
        conn = self.get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute('''
                SELECT 
                    COUNT(*) as total_messages,
                    COUNT(DISTINCT user_id) as unique_users,
                    AVG(processing_time) as avg_processing_time,
                    SUM(CASE WHEN status != 'success' THEN 1 ELSE 0 END) as errors
                FROM messages 
                WHERE timestamp >= datetime('now', '-{} days')
            '''.format(days))
            
            result = cursor.fetchone()
            return {
                'total_messages': result['total_messages'],
                'unique_users': result['unique_users'],
                'avg_processing_time': result['avg_processing_time'] or 0,
                'errors': result['errors']
            }
        except sqlite3.Error as e:
            logger.error(f"Database error in get_analytics: {e}")
            return {'total_messages': 0, 'unique_users': 0, 'avg_processing_time': 0, 'errors': 0}
        finally:
            conn.close()

# Initialize database manager
db_manager = DatabaseManager(config.db_name)

# Enhanced Rate Limiting
class RateLimiter:
    def __init__(self):
        self.user_requests: Dict[int, List[float]] = {}
        self.blocked_users: Dict[int, float] = {}
    
    def is_rate_limited(self, user_id: int) -> bool:
        """Check if user is rate limited with enhanced logic"""
        current_time = time.time()
        
        # Check if user is temporarily blocked
        if user_id in self.blocked_users:
            if current_time - self.blocked_users[user_id] < 300:  # 5 minutes block
                return True
            else:
                del self.blocked_users[user_id]
        
        # Initialize user if not exists
        if user_id not in self.user_requests:
            self.user_requests[user_id] = [current_time]
            return False
        
        # Remove old requests
        self.user_requests[user_id] = [
            t for t in self.user_requests[user_id] 
            if current_time - t < config.request_window
        ]
        
        # Check rate limit
        if len(self.user_requests[user_id]) >= config.request_limit:
            self.blocked_users[user_id] = current_time
            logger.warning(f"Rate limiting user {user_id}")
            return True
        
        self.user_requests[user_id].append(current_time)
        return False
    
    def get_remaining_requests(self, user_id: int) -> int:
        """Get remaining requests for user"""
        if user_id not in self.user_requests:
            return config.request_limit
        
        current_time = time.time()
        recent_requests = [
            t for t in self.user_requests[user_id] 
            if current_time - t < config.request_window
        ]
        
        return max(0, config.request_limit - len(recent_requests))

# Initialize rate limiter
rate_limiter = RateLimiter()

# Enhanced Message Formatting
class MessageFormatter:
    @staticmethod
    def split_message(text: str, max_length: int = None) -> List[str]:
        """Split long messages intelligently"""
        max_length = max_length or config.max_message_length
        
        if len(text) <= max_length:
            return [text]
        
        chunks = []
        while text:
            # Try to split at natural boundaries
            split_index = text.rfind('\n\n', 0, max_length)
            if split_index == -1:
                split_index = text.rfind('\n', 0, max_length)
            if split_index == -1:
                split_index = text.rfind('. ', 0, max_length)
            if split_index == -1:
                split_index = text.rfind(' ', 0, max_length)
            if split_index == -1:
                split_index = max_length
            
            chunk = text[:split_index].strip()
            if chunk:
                chunks.append(chunk)
            text = text[split_index:].strip()
        
        return chunks
    
    @staticmethod
    def markdown_to_html(text: str) -> str:
        """Convert Markdown to HTML with enhanced formatting"""
        # Escape HTML first
        text = html.escape(text)
        
        # Convert markdown patterns to HTML
        patterns = [
            (r'\*\*\*(.*?)\*\*\*', r'<b><i>\1</i></b>'),  # Bold + Italic
            (r'\*\*(.*?)\*\*', r'<b>\1</b>'),             # Bold
            (r'\*(.*?)\*', r'<i>\1</i>'),                 # Italic
            (r'__(.*?)__', r'<u>\1</u>'),                 # Underline
            (r'~~(.*?)~~', r'<s>\1</s>'),                 # Strikethrough
            (r'`(.*?)`', r'<code>\1</code>'),             # Inline code
            (r'```(.*?)```', r'<pre>\1</pre>'),           # Code block
            (r'\[(.*?)\]\((.*?)\)', r'<a href="\2">\1</a>'),  # Links
        ]
        
        for pattern, replacement in patterns:
            text = re.sub(pattern, replacement, text, flags=re.DOTALL)
        
        return text
    
    @staticmethod
    async def send_formatted_message(update: Update, text: str, 
                                   parse_mode: str = ParseMode.HTML) -> bool:
        """Send message with enhanced formatting and error handling"""
        chunks = MessageFormatter.split_message(text)
        
        for i, chunk in enumerate(chunks):
            try:
                # Add continuation indicator for multiple chunks
                if len(chunks) > 1:
                    if i == 0:
                        chunk += f"\n\nüìù *Message continues... ({i+1}/{len(chunks)})*"
                    elif i == len(chunks) - 1:
                        chunk = f"üìù *...continued ({i+1}/{len(chunks)})*\n\n" + chunk
                    else:
                        chunk = f"üìù *...continued ({i+1}/{len(chunks)})*\n\n" + chunk + f"\n\nüìù *Message continues...*"
                
                # Try HTML formatting first
                if parse_mode == ParseMode.HTML:
                    formatted_text = MessageFormatter.markdown_to_html(chunk)
                    await update.message.reply_text(
                        formatted_text,
                        parse_mode=ParseMode.HTML,
                        disable_web_page_preview=True
                    )
                else:
                    await update.message.reply_text(
                        chunk,
                        parse_mode=parse_mode,
                        disable_web_page_preview=True
                    )
                
                # Add delay between chunks
                if i < len(chunks) - 1:
                    await asyncio.sleep(0.5)
                    
            except Exception as e:
                logger.error(f"Formatting error: {e}")
                # Fallback to plain text
                try:
                    await update.message.reply_text(
                        chunk,
                        disable_web_page_preview=True
                    )
                except Exception as e2:
                    logger.error(f"Plain text fallback failed: {e2}")
                    return False
        
        return True

# Enhanced Telegram Handlers
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Enhanced start command with user statistics"""
    user = update.effective_user
    db_manager.register_user(user)
    
    user_stats = db_manager.get_user_stats(user.id)
    
    keyboard = [
        [InlineKeyboardButton("üìä My Statistics", callback_data="stats")],
        [InlineKeyboardButton("üîß Settings", callback_data="settings")],
        [InlineKeyboardButton("‚ÑπÔ∏è Help", callback_data="help")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    welcome_text = f"""
üëã *Welcome to VigilAI!*

I'm your advanced AI assistant powered by Google's Gemini AI. I can help you with:

ü§ñ **AI Chat**: Use `/askai` or mention me in groups
üìö **Smart Context**: I remember our conversation history
üîí **Privacy**: Your data is encrypted and secure
‚ö° **Fast Response**: Optimized for quick replies

*Your Stats:*
‚Ä¢ Messages sent: {user_stats['total_messages']}
‚Ä¢ Avg response time: {user_stats['avg_processing_time']:.2f}s
‚Ä¢ Member since: {user_stats['last_message'] or 'Just now'}

*Commands:*
‚Ä¢ `/askai <question>` - Ask me anything
‚Ä¢ `/reset` - Clear conversation context
‚Ä¢ `/stats` - View your usage statistics
‚Ä¢ `/help` - Show detailed help

Ready to chat? Try `/askai Hello, how are you?`
"""
    
    await update.message.reply_text(
        welcome_text,
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Enhanced help command with detailed information"""
    help_text = """
ü§ñ **VigilAI Help Guide**

**Basic Commands:**
‚Ä¢ `/start` - Initialize the bot and see your stats
‚Ä¢ `/help` - Show this help message
‚Ä¢ `/askai <question>` - Ask the AI a question
‚Ä¢ `/reset` - Clear conversation history
‚Ä¢ `/stats` - View your usage statistics
‚Ä¢ `/settings` - Manage your preferences

**Chat Features:**
‚Ä¢ **Smart Context**: I remember your conversation history
‚Ä¢ **Group Support**: Mention me (@VigilAIRobot) in groups
‚Ä¢ **Rich Formatting**: Supports markdown, code blocks, and links
‚Ä¢ **Multiple Languages**: Chat in your preferred language

**Usage Examples:**
‚Ä¢ `/askai What is quantum computing?`
‚Ä¢ `/askai Write a Python function to sort a list`
‚Ä¢ `/askai Explain machine learning in simple terms`

**Group Usage:**
‚Ä¢ Add me to your group
‚Ä¢ Make me an admin for full functionality
‚Ä¢ Mention me: `@VigilAIRobot your question here`

**Tips:**
‚Ä¢ Be specific in your questions for better responses
‚Ä¢ Use code blocks for programming questions
‚Ä¢ I can help with writing, analysis, math, and more!

**Privacy & Security:**
‚Ä¢ Messages are encrypted and secure
‚Ä¢ No data is shared with third parties
‚Ä¢ You can clear your history anytime

Need more help? Contact the admin or check our updates!
"""
    
    await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show user statistics"""
    user = update.effective_user
    user_stats = db_manager.get_user_stats(user.id)
    remaining_requests = rate_limiter.get_remaining_requests(user.id)
    
    stats_text = f"""
üìä **Your Statistics**

**Usage Stats:**
‚Ä¢ Total messages: {user_stats['total_messages']}
‚Ä¢ Average response time: {user_stats['avg_processing_time']:.2f}s
‚Ä¢ Last activity: {user_stats['last_message'] or 'Just now'}

**Rate Limits:**
‚Ä¢ Remaining requests: {remaining_requests}/{config.request_limit}
‚Ä¢ Reset window: {config.request_window} seconds

**Account Info:**
‚Ä¢ User ID: `{user.id}`
‚Ä¢ Username: @{user.username or 'Not set'}
‚Ä¢ Premium: {'Yes' if getattr(user, 'is_premium', False) else 'No'}

**Model Info:**
‚Ä¢ Current model: {gemini_manager.model_name}
‚Ä¢ Max history: {config.max_history_messages} messages
‚Ä¢ Max tokens: {config.max_history_tokens}

*Want to clear your history? Use `/reset`*
"""
    
    await update.message.reply_text(stats_text, parse_mode=ParseMode.MARKDOWN)

async def settings_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show user settings"""
    keyboard = [
        [InlineKeyboardButton("üîÑ Reset History", callback_data="reset_history")],
        [InlineKeyboardButton("üìä View Stats", callback_data="stats")],
        [InlineKeyboardButton("üîí Privacy Settings", callback_data="privacy")],
        [InlineKeyboardButton("üåê Language", callback_data="language")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    settings_text = """
‚öôÔ∏è **Settings**

Customize your VigilAI experience:

‚Ä¢ **Reset History**: Clear all conversation history
‚Ä¢ **View Stats**: See your usage statistics
‚Ä¢ **Privacy**: Manage your data preferences
‚Ä¢ **Language**: Change interface language

Select an option below:
"""
    
    await update.message.reply_text(
        settings_text,
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN
    )

async def handle_callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle inline keyboard callbacks"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "stats":
        await stats_command(update, context)
    elif query.data == "help":
        await help_command(update, context)
    elif query.data == "reset_history":
        user = query.from_user
        chat_id = query.message.chat.id
        if db_manager.clear_user_history(user.id, chat_id):
            await query.message.reply_text("üßπ Your chat history has been cleared!")
        else:
            await query.message.reply_text("‚ö†Ô∏è Failed to clear your history.")
    elif query.data == "privacy":
        # Placeholder for privacy settings
        await query.message.reply_text("üîí Privacy settings will be available soon!")
    elif query.data == "language":
        # Placeholder for language selection
        keyboard = [
            [InlineKeyboardButton("English", callback_data="lang_en")],
            [InlineKeyboardButton("Spanish", callback_data="lang_es")],
            [InlineKeyboardButton("French", callback_data="lang_fr")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.message.reply_text(
            "üåê Select your preferred language:",
            reply_markup=reply_markup
        )
    elif query.data.startswith("lang_"):
        # Placeholder for language implementation
        lang = query.data.split("_")[1]
        await query.message.reply_text(f"Language set to {lang.upper()}!")

async def reset_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Reset conversation context"""
    user = update.effective_user
    chat_id = update.message.chat.id
    if db_manager.clear_user_history(user.id, chat_id):
        await update.message.reply_text("üîÑ Conversation context has been reset!")
    else:
        await update.message.reply_text("‚ö†Ô∏è Failed to reset conversation context.")

async def ask_ai_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /askai command with enhanced processing"""
    user = update.effective_user
    chat_id = update.message.chat.id
    question = ' '.join(context.args).strip()

    if not question:
        await update.message.reply_text("Please provide a question after /askai command.")
        return

    # Check if in group and is admin
    if update.message.chat.type in ['group', 'supergroup']:
        try:
            chat_member = await context.bot.get_chat_member(
                chat_id=update.message.chat.id, 
                user_id=context.bot.id
            )
            if chat_member.status not in ['administrator', 'creator']:
                await update.message.reply_text(
                    "‚ö†Ô∏è I need to be an admin in this group to respond to commands. "
                    "Please make me an admin to use my features."
                )
                return
        except Exception as e:
            logger.error(f"Admin check error: {e}")
            return

    await process_ai_request(update, context, question, chat_id)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle all messages with enhanced processing"""
    message = update.message
    user = message.from_user
    db_manager.register_user(user)
    chat_id = message.chat.id

    # Register group if in a group
    if message.chat.type in ['group', 'supergroup']:
        db_manager.register_group(
            message.chat.id, 
            message.chat.title,
            message.chat.type
        )

        # Handle group mentions
        if message.text and f'@{context.bot.username}' in message.text:
            # Check if bot is admin in the group
            try:
                chat_member = await context.bot.get_chat_member(
                    chat_id=message.chat.id, 
                    user_id=context.bot.id
                )
                if chat_member.status not in ['administrator', 'creator']:
                    await message.reply_text(
                        "‚ö†Ô∏è I need to be an admin in this group to respond to messages. "
                        "Please make me an admin to use my features."
                    )
                    return
            except Exception as e:
                logger.error(f"Admin check error: {e}")
                return

            question = message.text.split(f'@{context.bot.username}', 1)[1].strip()
            await process_ai_request(update, context, question, chat_id)
    else:
        # Handle private messages
        if message.text and not message.text.startswith('/'):
            await process_ai_request(update, context, message.text.strip(), chat_id)

async def process_ai_request(update: Update, context: ContextTypes.DEFAULT_TYPE, 
                            question: str, chat_id: int):
    """Process AI request with enhanced features"""
    user = update.effective_user
    start_time = time.time()

    # Rate limiting
    if rate_limiter.is_rate_limited(user.id):
        remaining = rate_limiter.get_remaining_requests(user.id)
        await update.message.reply_text(
            f"‚è≥ You're sending requests too fast. Please wait. "
            f"Remaining requests: {remaining}/{config.request_limit}"
        )
        return

    try:
        # Show typing indicator
        await context.bot.send_chat_action(
            chat_id=update.effective_chat.id, 
            action=ChatAction.TYPING
        )

        # Get conversation history
        history = db_manager.get_chat_history(chat_id)
        
        # Generate response
        response_text = gemini_manager.generate_response(question, history)
        
        # Calculate processing time
        processing_time = time.time() - start_time
        
        # Add footer to successful responses
        if not response_text.startswith("‚ö†Ô∏è"):
            response_text += FOOTER
        
        # Send formatted response
        await MessageFormatter.send_formatted_message(update, response_text)
        
        # Save to DB
        db_manager.save_message(
            user.id,
            chat_id,
            question,
            response_text,
            tokens_used=len(response_text.split()),  # Approximate token count
            processing_time=processing_time,
            model_used=gemini_manager.model_name
        )

    except Exception as e:
        logger.error(f"AI processing error: {e}", exc_info=True)
        error_message = f"‚ö†Ô∏è Sorry, I encountered an error: {str(e)}"
        await update.message.reply_text(error_message)
        
        # Save error to DB
        db_manager.save_message(
            user.id,
            chat_id,
            question,
            None,
            status='error',
            error_message=str(e)
        )

# Set bot commands description
async def post_init(application: Application):
    try:
        await application.bot.set_my_commands([
            ("start", "Start the bot"),
            ("help", "Show help information"),
            ("askai", "Ask the AI a question"),
            ("reset", "Reset conversation context"),
            ("clearhistory", "Clear your chat history"),
            ("stats", "View your usage statistics"),
            ("settings", "Manage your preferences")
        ])
        logger.info("Bot commands set successfully")
    except Exception as e:
        logger.error(f"Error setting bot commands: {e}")

# Enhanced Flask Admin Interface
app = Flask(__name__)
app.secret_key = os.getenv('FLASK_SECRET', secrets.token_hex(32))

# Admin authentication
ADMIN_USERNAME = os.getenv('ADMIN_USERNAME', 'admin')
ADMIN_PASSWORD_HASH = generate_password_hash(
    os.getenv('ADMIN_PASSWORD', 'admin123')
)

@app.before_request
def require_login():
    if request.endpoint not in ['login', 'static'] and 'username' not in session:
        return redirect('/login')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        if username == ADMIN_USERNAME and check_password_hash(ADMIN_PASSWORD_HASH, password):
            session['username'] = username
            return redirect('/')
        return render_template_string(LOGIN_TEMPLATE, error="Invalid credentials")
    return render_template_string(LOGIN_TEMPLATE)

@app.route('/logout')
def logout():
    session.pop('username', None)
    return redirect('/login')

# Enhanced admin templates
LOGIN_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>Admin Login</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .login-box { max-width: 400px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #333; }
        input { width: 100%; padding: 10px; margin: 8px 0; box-sizing: border-box; }
        button { background: #4CAF50; color: white; padding: 12px; border: none; width: 100%; cursor: pointer; border-radius: 4px; }
        .error { color: red; text-align: center; }
    </style>
</head>
<body>
    <div class="login-box">
        <h1>Admin Login</h1>
        {% if error %}
            <p class="error">{{ error }}</p>
        {% endif %}
        <form method="POST">
            <input type="text" name="username" placeholder="Username" required>
            <input type="password" name="password" placeholder="Password" required>
            <button type="submit">Login</button>
        </form>
    </div>
</body>
</html>
"""

ADMIN_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>Telegram Bot Admin</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --success: #4cc9f0;
            --danger: #f72585;
            --dark: #212529;
            --light: #f8f9fa;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 0; 
            background-color: #f5f7fb; 
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary);
            margin: 10px 0;
        }
        
        .stat-label {
            color: #6c757d;
            font-size: 1rem;
        }
        
        .section {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        .section-title {
            margin-top: 0;
            color: var(--secondary);
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        
        .form-control:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: var(--secondary);
        }
        
        .btn-danger {
            background: var(--danger);
        }
        
        .btn-danger:hover {
            background: #d11465;
        }
        
        .message-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .message-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            display: flex;
        }
        
        .message-item:last-child {
            border-bottom: none;
        }
        
        .message-content {
            flex: 1;
        }
        
        .message-meta {
            font-size: 0.85rem;
            color: #6c757d;
            margin-top: 5px;
        }
        
        .user-tag {
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85rem;
            display: inline-block;
        }
        
        .analytics-chart {
            height: 300px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #6c757d;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        
        .tab.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .logout-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .logout-btn:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>VigilAI Admin Dashboard</h1>
            <form action="/logout" method="post">
                <button type="submit" class="logout-btn">Logout</button>
            </form>
        </div>
    </header>
    
    <div class="container">
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Total Users</div>
                <div class="stat-value">{{ user_count }}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Active Groups</div>
                <div class="stat-value">{{ group_count }}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Messages Today</div>
                <div class="stat-value">{{ messages_today }}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg Response Time</div>
                <div class="stat-value">{{ avg_response_time }}s</div>
            </div>
        </div>
        
        <div class="tabs">
            <div class="tab active" data-tab="dashboard">Dashboard</div>
            <div class="tab" data-tab="broadcast">Broadcast</div>
            <div class="tab" data-tab="analytics">Analytics</div>
            <div class="tab" data-tab="users">User Management</div>
        </div>
        
        <div class="tab-content active" id="dashboard">
            <div class="section">
                <h2 class="section-title">Recent Messages</h2>
                <div class="message-list">
                    {% for msg in recent_messages %}
                    <div class="message-item">
                        <div class="message-content">
                            <div><strong>{{ msg.username }} ({{ msg.user_id }})</strong></div>
                            <div>{{ msg.message_text }}</div>
                            <div class="message-meta">
                                {{ msg.timestamp }} | {{ msg.model_used }} | {{ msg.processing_time|round(2) }}s
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="broadcast">
            <div class="section">
                <h2 class="section-title">Broadcast Message</h2>
                <form method="POST" action="/broadcast">
                    <div class="form-group">
                        <textarea class="form-control" name="message" rows="5" placeholder="Your message to all users" required></textarea>
                    </div>
                    <button type="submit" class="btn">Send Broadcast</button>
                </form>
                {% if broadcast_result %}
                    <div class="broadcast-result" style="margin-top:20px; padding:15px; background:#e9ffed; border-radius:5px;">
                        <p>{{ broadcast_result }}</p>
                    </div>
                {% endif %}
                {% if broadcast_error %}
                    <div class="error" style="margin-top:20px; padding:15px; background:#ffebee; border-radius:5px;">
                        <p>{{ broadcast_error }}</p>
                    </div>
                {% endif %}
            </div>
        </div>
        
        <div class="tab-content" id="analytics">
            <div class="section">
                <h2 class="section-title">Analytics Overview</h2>
                <div class="analytics-chart">
                    Analytics Charts Will Appear Here (Integration with Chart.js would go here)
                </div>
                
                <h3 style="margin-top:30px;">Key Metrics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">7-Day Messages</div>
                        <div class="stat-value">{{ analytics_7d.total_messages }}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Unique Users</div>
                        <div class="stat-value">{{ analytics_7d.unique_users }}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Error Rate</div>
                        <div class="stat-value">{{ analytics_7d.error_rate }}%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Avg Response</div>
                        <div class="stat-value">{{ analytics_7d.avg_response_time }}s</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="users">
            <div class="section">
                <h2 class="section-title">User Management</h2>
                <div class="message-list">
                    {% for user in top_users %}
                    <div class="message-item">
                        <div class="message-content">
                            <div><strong>{{ user.username or 'User ' + user.user_id|string }}</strong></div>
                            <div>ID: {{ user.user_id }} | Messages: {{ user.message_count }}</div>
                            <div class="message-meta">
                                Last active: {{ user.last_active }}
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and contents
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding content
                    const tabId = tab.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
        });
    </script>
</body>
</html>
"""

@app.route('/')
def admin_dashboard():
    conn = db_manager.get_connection()
    cursor = conn.cursor()
    
    # Get stats
    cursor.execute('SELECT COUNT(*) FROM users')
    user_count = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM groups WHERE is_active = 1')
    group_count = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM messages WHERE DATE(timestamp) = DATE("now")')
    messages_today = cursor.fetchone()[0]
    
    cursor.execute('SELECT AVG(processing_time) FROM messages WHERE processing_time > 0')
    avg_response_time = round(cursor.fetchone()[0] or 0, 2)
    
    # Get recent messages
    cursor.execute('''
        SELECT m.message_text, m.timestamp, m.processing_time, m.model_used,
               u.user_id, u.username 
        FROM messages m
        JOIN users u ON m.user_id = u.user_id
        ORDER BY m.timestamp DESC
        LIMIT 10
    ''')
    recent_messages = [dict(row) for row in cursor.fetchall()]
    
    # Get 7-day analytics
    analytics_7d = db_manager.get_analytics(7)
    analytics_7d['error_rate'] = round(
        (analytics_7d['errors'] / max(1, analytics_7d['total_messages'])) * 100, 1
    ) if analytics_7d['total_messages'] > 0 else 0
    analytics_7d['avg_response_time'] = round(analytics_7d['avg_processing_time'], 2)
    
    # Get top users
    cursor.execute('''
        SELECT u.user_id, u.username, COUNT(m.id) as message_count, MAX(m.timestamp) as last_active
        FROM users u
        LEFT JOIN messages m ON u.user_id = m.user_id
        GROUP BY u.user_id
        ORDER BY message_count DESC
        LIMIT 10
    ''')
    top_users = [dict(row) for row in cursor.fetchall()]
    
    conn.close()
    
    return render_template_string(ADMIN_TEMPLATE,
        user_count=user_count,
        group_count=group_count,
        messages_today=messages_today,
        avg_response_time=avg_response_time,
        recent_messages=recent_messages,
        analytics_7d=analytics_7d,
        top_users=top_users
    )

@app.route('/broadcast', methods=['POST'])
def broadcast():
    message = request.form.get('message').strip()
    if not message:
        return jsonify({'error': 'Message cannot be empty'}), 400

    conn = db_manager.get_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT user_id FROM users')
    user_ids = [row[0] for row in cursor.fetchall()]
    conn.close()

    # Run broadcast in a separate thread
    def run_broadcast():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        bot = Bot(token=config.telegram_token)
        result = loop.run_until_complete(async_broadcast(bot, user_ids, message))
        loop.close()
        return result

    try:
        with ThreadPoolExecutor() as executor:
            future = executor.submit(run_broadcast)
            success, failures = future.result(timeout=300)
        return jsonify({
            'success': True,
            'message': f"Broadcast sent to {success} users. Failed: {failures}"
        })
    except Exception as e:
        logger.error(f"Broadcast execution error: {e}")
        return jsonify({'error': f"Broadcast failed: {str(e)}"}), 500

# Enhanced broadcast function
async def async_broadcast(bot, user_ids, message_text):
    success = 0
    failures = 0
    for user_id in user_ids:
        try:
            await bot.send_message(
                chat_id=user_id, 
                text=message_text,
                parse_mode=ParseMode.HTML
            )
            success += 1
            await asyncio.sleep(0.1)  # Rate limiting
        except (Forbidden, BadRequest) as e:
            logger.warning(f"Broadcast failed for {user_id}: {e.message}")
            failures += 1
        except TimedOut:
            logger.warning(f"Timeout for user {user_id}, retrying...")
            try:
                await bot.send_message(
                    chat_id=user_id, 
                    text=message_text,
                    parse_mode=ParseMode.HTML
                )
                success += 1
            except Exception as e2:
                logger.error(f"Retry failed for {user_id}: {e2}")
                failures += 1
        except Exception as e:
            logger.error(f"Broadcast failed for {user_id}: {e}")
            failures += 1
    return success, failures

# Database Backup System
def backup_database():
    """Regular database backup function"""
    backup_dir = Path('backups')
    backup_dir.mkdir(exist_ok=True)
    
    while True:
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = backup_dir / f"backup_{timestamp}.db"
            
            # Copy database
            with open(config.db_name, 'rb') as src, open(backup_path, 'wb') as dst:
                dst.write(src.read())
            
            logger.info(f"Database backup created: {backup_path}")
            
            # Clean up old backups (keep last 7)
            backups = sorted(backup_dir.glob('backup_*.db'), key=os.path.getmtime)
            if len(backups) > 7:
                for old_backup in backups[:-7]:
                    old_backup.unlink()
                    logger.info(f"Removed old backup: {old_backup}")
        
        except Exception as e:
            logger.error(f"Backup failed: {e}")
        
        # Wait until next backup
        time.sleep(config.backup_interval)

# Log Rotation System
def rotate_logs():
    """Regular log rotation function"""
    log_dir = Path('logs')
    log_dir.mkdir(exist_ok=True)
    
    while True:
        try:
            # Rotate main log
            main_log = log_dir / config.log_file
            if main_log.exists() and main_log.stat().st_size > 10 * 1024 * 1024:  # 10MB
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                rotated_log = log_dir / f"chatbot_{timestamp}.log"
                main_log.rename(rotated_log)
                logger.info(f"Rotated log file to {rotated_log}")
            
            # Clean up old logs
            for log_file in log_dir.glob('chatbot_*.log'):
                if (datetime.now() - datetime.fromtimestamp(log_file.stat().st_mtime) > 
                    timedelta(days=config.log_retention_days)):
                    log_file.unlink()
                    logger.info(f"Removed old log: {log_file}")
        
        except Exception as e:
            logger.error(f"Log rotation failed: {e}")
        
        # Check hourly
        time.sleep(3600)

# Main Application
def run_flask():
    app.run(host=config.flask_host, port=config.flask_port, use_reloader=False)

def main():
    # Validate token format
    try:
        test_bot = Bot(token=config.telegram_token)
        asyncio.get_event_loop().run_until_complete(test_bot.get_me())
        logger.info("Telegram token validated successfully")
    except InvalidToken as e:
        logger.error("Invalid Telegram token! Please check your .env file")
        return
    except Exception as e:
        logger.error("Error validating Telegram token: %s", e)
        return

    # Start maintenance threads
    threading.Thread(target=backup_database, daemon=True).start()
    threading.Thread(target=rotate_logs, daemon=True).start()
    
    # Start Flask in a separate thread
    threading.Thread(target=run_flask, daemon=True).start()

    # Create Telegram Application
    application = Application.builder() \
        .token(config.telegram_token) \
        .post_init(post_init) \
        .build()

    # Add handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("askai", ask_ai_command))
    application.add_handler(CommandHandler("reset", reset_command))
    application.add_handler(CommandHandler("stats", stats_command))
    application.add_handler(CommandHandler("settings", settings_command))
    application.add_handler(CallbackQueryHandler(handle_callback_query))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Start polling
    logger.info("Bot is running...")
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        close_loop=False
    )

if __name__ == '__main__':
    main()
